[
  {
    "markdown": "# The Python Tutorial[¶](https://docs.python.org/3/tutorial/#the-python-tutorial)\n\nPython is an easy to learn, powerful programming language. It has efficient\nhigh-level data structures and a simple but effective approach to\nobject-oriented programming. Python’s elegant syntax and dynamic typing,\ntogether with its interpreted nature, make it an ideal language for scripting\nand rapid application development in many areas on most platforms.\n\nThe Python interpreter and the extensive standard library are freely available\nin source or binary form for all major platforms from the Python web site,\n[https://www.python.org/](https://www.python.org/), and may be freely\ndistributed. The same site also\ncontains distributions of and pointers to many free third party Python modules,\nprograms and tools, and additional documentation.\n\nThe Python interpreter is easily extended with new functions and data types\nimplemented in C or C++ (or other languages callable from C). Python is also\nsuitable as an extension language for customizable applications.\n\nThis tutorial introduces the reader informally to the basic concepts and\nfeatures of the Python language and system. It helps to have a Python\ninterpreter handy for hands-on experience, but all examples are self-contained,\nso the tutorial can be read off-line as well.\n\nFor a description of standard objects and modules, see [The Python Standard\nLibrary](https://docs.python.org/3/library/index.html#library-index).\n[The Python Language\nReference](https://docs.python.org/3/reference/index.html#reference-index) gives\na more formal definition of the language. To write\nextensions in C or C++, read [Extending and Embedding the Python\nInterpreter](https://docs.python.org/3/extending/index.html#extending-index) and\n[Python/C API Reference\nManual](https://docs.python.org/3/c-api/index.html#c-api-index). There are also\nseveral books covering Python in depth.\n\nThis tutorial does not attempt to be comprehensive and cover every single\nfeature, or even every commonly used feature. Instead, it introduces many of\nPython’s most noteworthy features, and will give you a good idea of the\nlanguage’s flavor and style. After reading it, you will be able to read and\nwrite Python modules and programs, and you will be ready to learn more about the\nvarious Python library modules described in [The Python Standard\nLibrary](https://docs.python.org/3/library/index.html#library-index).\n\nThe [Glossary](https://docs.python.org/3/glossary.html#glossary) is also worth\ngoing through.\n\n \n \n\n## Links\n\n- [https://www.python.org/](https://www.python.org/)",
    "metadata": {
      "title": "The Python Tutorial — Python 3.13.2 documentation",
      "description": "Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax an...",
      "sourceURL": "https://docs.python.org/3/tutorial/"
    },
    "links": [
      "https://docs.python.org/3/tutorial/modules.html",
      "https://docs.python.org/3/tutorial/",
      "https://docs.python.org/3/tutorial/interpreter.html",
      "https://docs.python.org/3/tutorial/introduction.html",
      "https://docs.python.org/3/tutorial/errors.html",
      "https://docs.python.org/3/tutorial/venv.html",
      "https://docs.python.org/3/tutorial/stdlib2.html",
      "https://docs.python.org/3/tutorial/datastructures.html",
      "https://docs.python.org/3/tutorial/classes.html",
      "https://docs.python.org/3/tutorial/stdlib.html",
      "https://docs.python.org/3/tutorial/inputoutput.html",
      "https://docs.python.org/3/tutorial/appetite.html",
      "https://docs.python.org/3/tutorial/whatnow.html",
      "https://docs.python.org/3/tutorial/appendix.html",
      "https://docs.python.org/3/tutorial/floatingpoint.html",
      "https://docs.python.org/3/tutorial/controlflow.html",
      "https://docs.python.org/3/tutorial/interactive.html"
    ]
  },
  {
    "markdown": "# 6. Modules[¶](https://docs.python.org/3/tutorial/modules.html#modules)\n\nIf you quit from the Python interpreter and enter it again, the definitions you\nhave made (functions and variables) are lost. Therefore, if you want to write a\nsomewhat longer program, you are better off using a text editor to prepare the\ninput for the interpreter and running it with that file as input instead. This\nis known as creating a *script*. As your program gets longer, you may want to\nsplit it into several files for easier maintenance. You may also want to use a\nhandy function that you’ve written in several programs without copying its\ndefinition into each program.\n\nTo support this, Python has a way to put definitions in a file and use them in a\nscript or in an interactive instance of the interpreter. Such a file is called a\n*module*; definitions from a module can be *imported* into other modules or into\nthe *main* module (the collection of variables that you have access to in a\nscript executed at the top level and in calculator mode).\n\nA module is a file containing Python definitions and statements. The file name\nis the module name with the suffix `.py` appended. Within a module, the\nmodule’s name (as a string) is available as the value of the global variable\n`__name__`. For instance, use your favorite text editor to create a file\ncalled `fibo.py` in the current directory with the following contents:\n\n```\n# Fibonacci numbers module\n\ndef fib(n): # write Fibonacci series up to n\n a, b = 0, 1\n while a < n:\n print(a, end=' ')\n a, b = b, a+b\n print()\n\ndef fib2(n): # return Fibonacci series up to n\n result = []\n a, b = 0, 1\n while a < n:\n result.append(a)\n a, b = b, a+b\n return result\n\n```\n\nNow enter the Python interpreter and import this module with the following\ncommand:\n\n>>>\n```\n>>> import fibo\n\n```\n\nThis does not add the names of the functions defined in `fibo` directly to\nthe current [namespace](https://docs.python.org/3/glossary.html#term-namespace)\n(see [Python Scopes and\nNamespaces](https://docs.python.org/3/tutorial/classes.html#tut-scopes) for more\ndetails);\nit only adds the module name `fibo` there. Using\nthe module name you can access the functions:\n\n>>>\n```\n>>> fibo.fib(1000)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987\n>>> fibo.fib2(100)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n>>> fibo.__name__\n'fibo'\n\n```\n\nIf you intend to use a function often you can assign it to a local name:\n\n>>>\n```\n>>> fib = fibo.fib\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n```\n\n## 6.1. More on Modules[¶](https://docs.python.org/3/tutorial/modules.html#more-on-modules)\n\nA module can contain executable statements as well as function definitions.\nThese statements are intended to initialize the module. They are executed only\nthe *first* time the module name is encountered in an import statement.\n[[1]](https://docs.python.org/3/tutorial/modules.html#id3)\n(They are also run if the file is executed as a script.)\n\nEach module has its own private namespace, which is used as the global namespace\nby all functions defined in the module. Thus, the author of a module can\nuse global variables in the module without worrying about accidental clashes\nwith a user’s global variables. On the other hand, if you know what you are\ndoing you can touch a module’s global variables with the same notation used to\nrefer to its functions, `modname.itemname`.\n\nModules can import other modules. It is customary but not required to place all\n[import](https://docs.python.org/3/reference/simple_stmts.html#import)\nstatements at the beginning of a module (or script, for that\nmatter). The imported module names, if placed at the top level of a module\n(outside any functions or classes), are added to the module’s global namespace.\n\nThere is a variant of the\n[import](https://docs.python.org/3/reference/simple_stmts.html#import) statement\nthat imports names from a\nmodule directly into the importing module’s namespace. For example:\n\n>>>\n```\n>>> from fibo import fib, fib2\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n```\n\nThis does not introduce the module name from which the imports are taken in the\nlocal namespace (so in the example, `fibo` is not defined).\n\nThere is even a variant to import all names that a module defines:\n\n>>>\n```\n>>> from fibo import *\n>>> fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n```\n\nThis imports all names except those beginning with an underscore (`_`).\nIn most cases Python programmers do not use this facility since it introduces\nan unknown set of names into the interpreter, possibly hiding some things\nyou have already defined.\n\nNote that in general the practice of importing `*` from a module or package is\nfrowned upon, since it often causes poorly readable code. However, it is okay to\nuse it to save typing in interactive sessions.\n\nIf the module name is followed by `as`, then the name\nfollowing `as` is bound directly to the imported module.\n\n>>>\n```\n>>> import fibo as fib\n>>> fib.fib(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n```\n\nThis is effectively importing the module in the same way that `import fibo`\nwill do, with the only difference of it being available as `fib`.\n\nIt can also be used when utilising\n[from](https://docs.python.org/3/reference/simple_stmts.html#from) with similar\neffects:\n\n>>>\n```\n>>> from fibo import fib as fibonacci\n>>> fibonacci(500)\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377\n\n```\n\nNote\n\nFor efficiency reasons, each module is only imported once per interpreter\nsession. Therefore, if you change your modules, you must restart the\ninterpreter – or, if it’s just one module you want to test interactively,\nuse\n[importlib.reload()](https://docs.python.org/3/library/importlib.html#importlib.reload),\ne.g. `import importlib;\nimportlib.reload(modulename)`.\n\n### 6.1.1. Executing modules as scripts[¶](https://docs.python.org/3/tutorial/modules.html#executing-modules-as-scripts)\n\nWhen you run a Python module with\n\n```\npython fibo.py <arguments>\n\n```\n\nthe code in the module will be executed, just as if you imported it, but with\nthe `__name__` set to `\"__main__\"`. That means that by adding this code at\nthe end of your module:\n\n```\nif __name__ == \"__main__\":\n import sys\n fib(int(sys.argv[1]))\n\n```\n\nyou can make the file usable as a script as well as an importable module,\nbecause the code that parses the command line only runs if the module is\nexecuted as the “main” file:\n\n```\n$ python fibo.py 50\n0 1 1 2 3 5 8 13 21 34\n\n```\n\nIf the module is imported, the code is not run:\n\n>>>\n```\n>>> import fibo\n>>>\n\n```\n\nThis is often used either to provide a convenient user interface to a module, or\nfor testing purposes (running the module as a script executes a test suite).\n\n### 6.1.2. The Module Search Path[¶](https://docs.python.org/3/tutorial/modules.html#the-module-search-path)\n\nWhen a module named `spam` is imported, the interpreter first searches for\na built-in module with that name. These module names are listed in\n\n[sys.builtin_module_names](https://docs.python.org/3/library/sys.html#sys.builtin_module_names).\nIf not found, it then searches for a file\nnamed `spam.py` in a list of directories given by the variable\n[sys.path](https://docs.python.org/3/library/sys.html#sys.path).\n[sys.path](https://docs.python.org/3/library/sys.html#sys.path) is initialized\nfrom these locations:\n\n- The directory containing the input script (or the current directory when no\nfile is specified).\n\n- [PYTHONPATH](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH)\n(a list of directory names, with the same syntax as the\nshell variable `PATH`).\n\n- The installation-dependent default (by convention including a\n`site-packages` directory, handled by the\n[site](https://docs.python.org/3/library/site.html#module-site) module).\n\nMore details are at [The initialization of the sys.path module search\npath](https://docs.python.org/3/library/sys_path_init.html#sys-path-init).\n\nNote\n\nOn file systems which support symlinks, the directory containing the input\nscript is calculated after the symlink is followed. In other words the\ndirectory containing the symlink is **not** added to the module search path.\n\nAfter initialization, Python programs can modify\n[sys.path](https://docs.python.org/3/library/sys.html#sys.path). The\ndirectory containing the script being run is placed at the beginning of the\nsearch path, ahead of the standard library path. This means that scripts in that\ndirectory will be loaded instead of modules of the same name in the library\ndirectory. This is an error unless the replacement is intended. See section\n[Standard\nModules](https://docs.python.org/3/tutorial/modules.html#tut-standardmodules)\nfor more information.\n\n### 6.1.3. “Compiled” Python files[¶](https://docs.python.org/3/tutorial/modules.html#compiled-python-files)\n\nTo speed up loading modules, Python caches the compiled version of each module\nin the `__pycache__` directory under the name `module.version.pyc`,\nwhere the version encodes the format of the compiled file; it generally contains\nthe Python version number. For example, in CPython release 3.3 the compiled\nversion of spam.py would be cached as `__pycache__/spam.cpython-33.pyc`. This\nnaming convention allows compiled modules from different releases and different\nversions of Python to coexist.\n\nPython checks the modification date of the source against the compiled version\nto see if it’s out of date and needs to be recompiled. This is a completely\nautomatic process. Also, the compiled modules are platform-independent, so the\nsame library can be shared among systems with different architectures.\n\nPython does not check the cache in two circumstances. First, it always\nrecompiles and does not store the result for the module that’s loaded directly\nfrom the command line. Second, it does not check the cache if there is no\nsource module. To support a non-source (compiled only) distribution, the\ncompiled module must be in the source directory, and there must not be a source\nmodule.\n\nSome tips for experts:\n\n- You can use the [-O](https://docs.python.org/3/using/cmdline.html#cmdoption-O)\nor [-OO](https://docs.python.org/3/using/cmdline.html#cmdoption-OO) switches on\nthe Python command\nto reduce the size of a compiled module. The `-O` switch removes assert\nstatements, the `-OO` switch removes both assert statements and __doc__\nstrings. Since some programs may rely on having these available, you should\nonly use this option if you know what you’re doing. “Optimized” modules have\nan `opt-` tag and are usually smaller. Future releases may\nchange the effects of optimization.\n\n- A program doesn’t run any faster when it is read from a `.pyc`\nfile than when it is read from a `.py` file; the only thing that’s faster\nabout `.pyc` files is the speed with which they are loaded.\n\n- The module\n[compileall](https://docs.python.org/3/library/compileall.html#module-compileall)\ncan create .pyc files for all modules in a\ndirectory.\n\n- There is more detail on this process, including a flow chart of the\ndecisions, in [PEP 3147](https://peps.python.org/pep-3147/).\n\n## 6.2. Standard Modules[¶](https://docs.python.org/3/tutorial/modules.html#standard-modules)\n\nPython comes with a library of standard modules, described in a separate\ndocument, the Python Library Reference (“Library Reference” hereafter). Some\nmodules are built into the interpreter; these provide access to operations that\nare not part of the core of the language but are nevertheless built in, either\nfor efficiency or to provide access to operating system primitives such as\nsystem calls. The set of such modules is a configuration option which also\ndepends on the underlying platform. For example, the\n[winreg](https://docs.python.org/3/library/winreg.html#module-winreg) module is\nonly\nprovided on Windows systems. One particular module deserves some attention:\n[sys](https://docs.python.org/3/library/sys.html#module-sys), which is built\ninto every Python interpreter. The variables\n`sys.ps1` and `sys.ps2` define the strings used as primary and secondary\nprompts:\n\n>>>\n```\n>>> import sys\n>>> sys.ps1\n'>>> '\n>>> sys.ps2\n'... '\n>>> sys.ps1 = 'C> '\nC> print('Yuck!')\nYuck!\nC>\n\n```\n\nThese two variables are only defined if the interpreter is in interactive mode.\n\nThe variable `sys.path` is a list of strings that determines the interpreter’s\nsearch path for modules. It is initialized to a default path taken from the\nenvironment variable\n[PYTHONPATH](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH), or\nfrom a built-in default if\n[PYTHONPATH](https://docs.python.org/3/using/cmdline.html#envvar-PYTHONPATH) is\nnot set. You can modify it using standard list\noperations:\n\n>>>\n```\n>>> import sys\n>>> sys.path.append('/ufs/guido/lib/python')\n\n```\n\n## 6.3. The [dir()](https://docs.python.org/3/library/functions.html#dir) Function[¶](https://docs.python.org/3/tutorial/modules.html#the-dir-function)\n\nThe built-in function\n[dir()](https://docs.python.org/3/library/functions.html#dir) is used to find\nout which names a module\ndefines. It returns a sorted list of strings:\n\n>>>\n```\n>>> import fibo, sys\n>>> dir(fibo)\n['__name__', 'fib', 'fib2']\n>>> dir(sys)\n['__breakpointhook__', '__displayhook__', '__doc__', '__excepthook__',\n '__interactivehook__', '__loader__', '__name__', '__package__', '__spec__',\n '__stderr__', '__stdin__', '__stdout__', '__unraisablehook__',\n '_clear_type_cache', '_current_frames', '_debugmallocstats', '_framework',\n '_getframe', '_git', '_home', '_xoptions', 'abiflags', 'addaudithook',\n 'api_version', 'argv', 'audit', 'base_exec_prefix', 'base_prefix',\n 'breakpointhook', 'builtin_module_names', 'byteorder', 'call_tracing',\n 'callstats', 'copyright', 'displayhook', 'dont_write_bytecode', 'exc_info',\n 'excepthook', 'exec_prefix', 'executable', 'exit', 'flags', 'float_info',\n'float_repr_style', 'get_asyncgen_hooks', 'get_coroutine_origin_tracking_depth',\n 'getallocatedblocks', 'getdefaultencoding', 'getdlopenflags',\n 'getfilesystemencodeerrors', 'getfilesystemencoding', 'getprofile',\n 'getrecursionlimit', 'getrefcount', 'getsizeof', 'getswitchinterval',\n 'gettrace', 'hash_info', 'hexversion', 'implementation', 'int_info',\n 'intern', 'is_finalizing', 'last_traceback', 'last_type', 'last_value',\n 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path', 'path_hooks',\n 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2', 'pycache_prefix',\n 'set_asyncgen_hooks', 'set_coroutine_origin_tracking_depth', 'setdlopenflags',\n 'setprofile', 'setrecursionlimit', 'setswitchinterval', 'settrace', 'stderr',\n 'stdin', 'stdout', 'thread_info', 'unraisablehook', 'version', 'version_info',\n 'warnoptions']\n\n```\n\nWithout arguments, [dir()](https://docs.python.org/3/library/functions.html#dir)\nlists the names you have defined currently:\n\n>>>\n```\n>>> a = [1, 2, 3, 4, 5]\n>>> import fibo\n>>> fib = fibo.fib\n>>> dir()\n['__builtins__', '__name__', 'a', 'fib', 'fibo', 'sys']\n\n```\n\nNote that it lists all types of names: variables, modules, functions, etc.\n\n[dir()](https://docs.python.org/3/library/functions.html#dir) does not list the\nnames of built-in functions and variables. If you\nwant a list of those, they are defined in the standard module\n[builtins](https://docs.python.org/3/library/builtins.html#module-builtins):\n\n>>>\n```\n>>> import builtins\n>>> dir(builtins)\n['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException',\n 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning',\n 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError',\n 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning',\n 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False',\n 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError',\n 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError',\n 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError',\n 'MemoryError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented',\n 'NotImplementedError', 'OSError', 'OverflowError',\n 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError',\n 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning',\n 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError',\n 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n 'ValueError', 'Warning', 'ZeroDivisionError', '_', '__build_class__',\n '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs',\n 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable',\n 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits',\n 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit',\n 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr',\n 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass',\n 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview',\n 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property',\n 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice',\n 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars',\n 'zip']\n\n```\n\n## 6.4. Packages[¶](https://docs.python.org/3/tutorial/modules.html#packages)\n\nPackages are a way of structuring Python’s module namespace by using “dotted\nmodule names”. For example, the module name `A.B` designates a submodule\nnamed `B` in a package named `A`. Just like the use of modules saves the\nauthors of different modules from having to worry about each other’s global\nvariable names, the use of dotted module names saves the authors of multi-module\npackages like NumPy or Pillow from having to worry about\neach other’s module names.\n\nSuppose you want to design a collection of modules (a “package”) for the uniform\nhandling of sound files and sound data. There are many different sound file\nformats (usually recognized by their extension, for example: `.wav`,\n`.aiff`, `.au`), so you may need to create and maintain a growing\ncollection of modules for the conversion between the various file formats.\nThere are also many different operations you might want to perform on sound data\n(such as mixing, adding echo, applying an equalizer function, creating an\nartificial stereo effect), so in addition you will be writing a never-ending\nstream of modules to perform these operations. Here’s a possible structure for\nyour package (expressed in terms of a hierarchical filesystem):\n\n```\nsound/ Top-level package\n __init__.py Initialize the sound package\n formats/ Subpackage for file format conversions\n __init__.py\n wavread.py\n wavwrite.py\n aiffread.py\n aiffwrite.py\n auread.py\n auwrite.py\n ...\n effects/ Subpackage for sound effects\n __init__.py\n echo.py\n surround.py\n reverse.py\n ...\n filters/ Subpackage for filters\n __init__.py\n equalizer.py\n vocoder.py\n karaoke.py\n ...\n\n```\n\nWhen importing the package, Python searches through the directories on\n`sys.path` looking for the package subdirectory.\n\nThe `__init__.py` files are required to make Python treat directories\ncontaining the file as packages (unless using a [namespace\npackage](https://docs.python.org/3/glossary.html#term-namespace-package), a\nrelatively advanced feature). This prevents directories with a common name,\nsuch as `string`, from unintentionally hiding valid modules that occur later\non the module search path. In the simplest case, `__init__.py` can just be\nan empty file, but it can also execute initialization code for the package or\nset the `__all__` variable, described later.\n\nUsers of the package can import individual modules from the package, for\nexample:\n\n```\nimport sound.effects.echo\n\n```\n\nThis loads the submodule `sound.effects.echo`. It must be referenced with\nits full name.\n\n```\nsound.effects.echo.echofilter(input, output, delay=0.7, atten=4)\n\n```\n\nAn alternative way of importing the submodule is:\n\n```\nfrom sound.effects import echo\n\n```\n\nThis also loads the submodule `echo`, and makes it available without its\npackage prefix, so it can be used as follows:\n\n```\necho.echofilter(input, output, delay=0.7, atten=4)\n\n```\n\nYet another variation is to import the desired function or variable directly:\n\n```\nfrom sound.effects.echo import echofilter\n\n```\n\nAgain, this loads the submodule `echo`, but this makes its function\n`echofilter()` directly available:\n\n```\nechofilter(input, output, delay=0.7, atten=4)\n\n```\n\nNote that when using `from package import item`, the item can be either a\nsubmodule (or subpackage) of the package, or some other name defined in the\npackage, like a function, class or variable. The `import` statement first\ntests whether the item is defined in the package; if not, it assumes it is a\nmodule and attempts to load it. If it fails to find it, an\n[ImportError](https://docs.python.org/3/library/exceptions.html#ImportError)\nexception is raised.\n\nContrarily, when using syntax like `import item.subitem.subsubitem`, each item\nexcept for the last must be a package; the last item can be a module or a\npackage but can’t be a class or function or variable defined in the previous\nitem.\n\n### 6.4.1. Importing * From a Package[¶](https://docs.python.org/3/tutorial/modules.html#importing-from-a-package)\n\nNow what happens when the user writes `from sound.effects import *`? Ideally,\none would hope that this somehow goes out to the filesystem, finds which\nsubmodules are present in the package, and imports them all. This could take a\nlong time and importing sub-modules might have unwanted side-effects that should\nonly happen when the sub-module is explicitly imported.\n\nThe only solution is for the package author to provide an explicit index of the\npackage. The\n[import](https://docs.python.org/3/reference/simple_stmts.html#import) statement\nuses the following convention: if a package’s\n`__init__.py` code defines a list named `__all__`, it is taken to be the\nlist of module names that should be imported when `from package import *` is\nencountered. It is up to the package author to keep this list up-to-date when a\nnew version of the package is released. Package authors may also decide not to\nsupport it, if they don’t see a use for importing * from their package. For\nexample, the file `sound/effects/__init__.py` could contain the following\ncode:\n\n```\n__all__ = [\"echo\", \"surround\", \"reverse\"]\n\n```\n\nThis would mean that `from sound.effects import *` would import the three\nnamed submodules of the `sound.effects` package.\n\nBe aware that submodules might become shadowed by locally defined names. For\nexample, if you added a `reverse` function to the\n`sound/effects/__init__.py` file, the `from sound.effects import *`\nwould only import the two submodules `echo` and `surround`, but *not* the\n`reverse` submodule, because it is shadowed by the locally defined\n`reverse` function:\n\n```\n__all__ = [\n \"echo\", # refers to the 'echo.py' file\n \"surround\", # refers to the 'surround.py' file\n \"reverse\", # !!! refers to the 'reverse' function now !!!\n]\n\ndef reverse(msg: str): # <-- this name shadows the 'reverse.py' submodule\n return msg[::-1] # in the case of a 'from sound.effects import *'\n\n```\n\nIf `__all__` is not defined, the statement `from sound.effects import *`\ndoes *not* import all submodules from the package `sound.effects` into the\ncurrent namespace; it only ensures that the package `sound.effects` has\nbeen imported (possibly running any initialization code in `__init__.py`)\nand then imports whatever names are defined in the package. This includes any\nnames defined (and submodules explicitly loaded) by `__init__.py`. It\nalso includes any submodules of the package that were explicitly loaded by\nprevious [import](https://docs.python.org/3/reference/simple_stmts.html#import)\nstatements. Consider this code:\n\n```\nimport sound.effects.echo\nimport sound.effects.surround\nfrom sound.effects import *\n\n```\n\nIn this example, the `echo` and `surround` modules are imported in the\ncurrent namespace because they are defined in the `sound.effects` package\nwhen the `from...import` statement is executed. (This also works when\n`__all__` is defined.)\n\nAlthough certain modules are designed to export only names that follow certain\npatterns when you use `import *`, it is still considered bad practice in\nproduction code.\n\nRemember, there is nothing wrong with using `from package import\nspecific_submodule`! In fact, this is the recommended notation unless the\nimporting module needs to use submodules with the same name from different\npackages.\n\n### 6.4.2. Intra-package References[¶](https://docs.python.org/3/tutorial/modules.html#intra-package-references)\n\nWhen packages are structured into subpackages (as with the `sound` package\nin the example), you can use absolute imports to refer to submodules of siblings\npackages. For example, if the module `sound.filters.vocoder` needs to use\nthe `echo` module in the `sound.effects` package, it can use `from\nsound.effects import echo`.\n\nYou can also write relative imports, with the `from module import name` form\nof import statement. These imports use leading dots to indicate the current and\nparent packages involved in the relative import. From the `surround`\nmodule for example, you might use:\n\n```\nfrom . import echo\nfrom .. import formats\nfrom ..filters import equalizer\n\n```\n\nNote that relative imports are based on the name of the current module. Since\nthe name of the main module is always `\"__main__\"`, modules intended for use\nas the main module of a Python application must always use absolute imports.\n\n### 6.4.3. Packages in Multiple Directories[¶](https://docs.python.org/3/tutorial/modules.html#packages-in-multiple-directories)\n\nPackages support one more special attribute,\n[__path__](https://docs.python.org/3/reference/datamodel.html#module.__path__).\nThis is\ninitialized to be a\n[sequence](https://docs.python.org/3/glossary.html#term-sequence) of strings\ncontaining the name of the\ndirectory holding the\npackage’s `__init__.py` before the code in that file is executed. This\nvariable can be modified; doing so affects future searches for modules and\nsubpackages contained in the package.\n\nWhile this feature is not often needed, it can be used to extend the set of\nmodules found in a package.\n\nFootnotes\n\n \n \n\n## Links\n\n- [PEP 3147](https://peps.python.org/pep-3147/)",
    "metadata": {
      "title": "6. Modules — Python 3.13.2 documentation",
      "description": "If you quit from the Python interpreter and enter it again, the definitions you have made (functions and variables) are lost. Therefore, if you want to write a somewhat longer program, you are bett...",
      "sourceURL": "https://docs.python.org/3/tutorial/modules.html"
    },
    "links": [
      "https://docs.python.org/3/tutorial/modules.html"
    ]
  }
]