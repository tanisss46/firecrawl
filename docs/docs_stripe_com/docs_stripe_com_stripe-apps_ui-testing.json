{
  "content": "# UI testing\n\n## Test your Stripe app UI with a set of utilities and helpers.\n\nThe Extension SDK includes a set of tools to write unit tests for your app’s\nuser interface. We recommend running tests with [Jest](https://jestjs.io/) and\nwe include [Jest custom\nmatchers](https://docs.stripe.com/stripe-apps/ui-testing#matchers) to help with\nwriting assertions.\n\n## Conceptual overview\n\nWhen testing your Stripe app’s UI, you’re testing a remote engine that renders\nyour app, not the Document Object Model (DOM) tree directly.\n\nFor security purposes, the React code in your Stripe app repository is\nserialized, sent through an extension loader using an iframe, and translated\ninto a DOM tree within the Stripe Dashboard. The testing tools provided by the\nExtension SDK work with the remote rendering engine.\n\n## Example\n\nThis example tests a\n[Button](https://docs.stripe.com/stripe-apps/components/button) UI component\nthat changes text when clicked. In the test, we render the button, confirm that\nthe initial button text is correct, click the button, and confirm that the text\nof the button has changed.\n\n```\n// App.tsx\nimport {useState} from 'react';\nimport {ContextView, Button} from '@stripe/ui-extension-sdk/ui';\n\nconst App = () => {\n const [isPressed, setIsPressed] = useState(false);\n return (\n <ContextView title=\"Hello world\">\n <Button onPress={() => setIsPressed(true)}>\n {isPressed ? 'You pressed me!' : 'Press me'}\n </Button>\n </ContextView>\n );\n};\n\nexport default App;\n\n// App.test.tsx\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport {Button} from '@stripe/ui-extension-sdk/ui';\nimport App from './App';\n\ndescribe('App', () => {\n it('changes button text when pressed', async () => {\n const {wrapper, update} = render(<App />);\n\n // Expect that the initial text is correct\n expect(wrapper.find(Button)).toContainText('Press me');\n\n // Press the button\n wrapper.find(Button)!.trigger('onPress');\n\n // This is needed if the \"onPress\" handler involves something asyncronous\n // like a promise or a React useEffect hook\n await update();\n\n // Expect that the text changed\n expect(wrapper.find(Button)).toContainText('You pressed me!');\n });\n});\n```\n\n## Rendering a component\n\n### `render(element: React.ReactElement)`\n\nThe `render` method accepts a React element and returns an object with the\nfollowing properties:\n\n- `wrapper`: The root element of the component passed to `render`.\n- `update`: A function that returns a promise that resolves after the JavaScript\nevent stack has been cleared. This is useful when mocking APIs, dealing with\npromises, employing React hooks such as `useEffect`, or ensuring asynchronous\nrendering completes before running subsequent test cases.\n\n```\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport App from './App';\n\nit('contains a Button', async () => {\n const {wrapper, update} = render(<App />);\n\n await update();\n\n // Continue testing...\n});\n```\n\n## Element properties and methods\n\nWhen working with the wrapper or any element within it, use the following\nproperties and methods to assess state and interact with your app:\n\n### children: Element<unknown>[]\n\nReturns an array of the direct children of the element.\n\n### descendants: Element<unknown>[]\n\nReturns an array of all elements below the element in the tree.\n\n### debug(options?: {all?: boolean, depth?: number, verbosity?: number}): string\n\nReturns a text representation of the element. You can modify `debug()` output\nusing the `options` parameter.\n\n- `all` overrides the default props filtering behavior and instead includes all\nprops in the output. `debug()` omits `className`, `aria-*`, and `data-*` props\nby default.\n- `depth` defines the number of children printed. All children are printed by\ndefault.\n- `verbosity` defines the level of expansion for non-scalar props. The default\nvalue of `1` expands objects one level deep.\n\n### act<T>(action: () => T): T\n\nPerforms an action in the context of a React [act()\nblock](https://reactjs.org/docs/test-utils.html#act). Normally, you can use\n`update()` (which uses `act()` internally) to handle asynchronous events.\nHowever, in some cases you might need to call `act()` directly, such as when\nyour code uses timers (`setTimeout`, `setInterval`, `clearTimeout`,\n`clearInterval`), and you want to test using [timer\nmocks](https://jestjs.io/docs/timer-mocks). When using timer mocks, you need to\nreset or cleanup mocks between tests (in jest this means calling\n`runOnlyPendingTimers()` and `useRealTimers()`), otherwise library code that\nuses timers won’t work properly.\n\n### find(type: Type, props?: Partial<PropsForComponent<Type>>): Element<PropsForComponent<Type>> | null\n\nFinds a descendant element that matches `type`, where `type` is a component. If\nit doesn’t find a matching element, it returns null. If it finds a match, the\nreturned element has the correct prop typing, which provides excellent type\nsafety while navigating the React tree.\n\nIf the second `props` argument is passed, it finds the first element of `type`\nwith matching `props`.\n\n```\n// App.tsx\nimport {Button, ContextView} from '@stripe/ui-extension-sdk/ui';\n\nconst App = () => (\n <ContextView title=\"Hello world\">\n <Button href=\"http://bad.example.com\">Do not press me</Button>\n <Button href=\"http://example.com\">Press me</Button>\n </ContextView>\n);\n\nexport default App;\n\n// App.test.tsx\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport {Button} from '@stripe/ui-extension-sdk/ui';\nimport App from './App';\n\nit('contains a Button with text', () => {\n const {wrapper} = render(<App />);\n\n const button = wrapper.find(Button, {href: 'http://example.com'});\n\n expect(button).toContainText('Press me');\n});\n```\n\nBe aware that when using any of the `findX` methods, saved results are\nimmediately stale and future updates to the component aren’t reflected. For\nexample:\n\n```\n// Bad - this will not work\nconst button = wrapper.find(Button);\nexpect(button).toContainText('Press me');\nbutton!.trigger('onPress');\nexpect(button).toContainText('You pressed me!'); // button still contains 'Press\nme'\n\n// Good - this will work\nexpect(wrapper.find(Button)).toContainText('Press me');\nwrapper.find(Button)!.trigger('onPress');\nexpect(wrapper.find(Button)).toContainText('You pressed me!');\n```\n\n### findAll(type: Type, props?: Partial<PropsForComponent<Type>>): Element<PropsForComponent<Type>>[]\n\nLike `find`, but returns all matches as an array.\n\n### findWhere<Type = unknown>(predicate: (element: Element<unknown>) => boolean): Element<PropsForComponent<Type>> | null\n\nFinds the first descendant component matching the passed function. The function\nis called with each element from `descendants` until it finds a match. If it\ndoesn’t find a match, it returns `null`.\n\n`findWhere` accepts an optional TypeScript argument that you can use to specify\nthe type of the returned element. If you omit the generic argument, the returned\nelement has unknown props, so calling `.props` and `.trigger` on it causes type\nerrors, as those functions don’t know what props are valid on your element:\n\n```\n// App.tsx\nimport {Button, ContextView} from '@stripe/ui-extension-sdk/ui';\n\nconst App = () => (\n <ContextView title=\"Hello world\">\n <Button href=\"http://example.com\">Press me</Button>\n </ContextView>\n);\n\nexport default App;\n\n// App.test.tsx\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport {Button} from '@stripe/ui-extension-sdk/ui';\nimport App from './App';\n\nit('contains a Button with a href', () => {\n const {wrapper} = render(<App />);\n\n const button = wrapper.findWhere<typeof Button>(\n (node) => node.is(Button) && node.prop('href').startsWith('http://example'),\n );\n\n expect(button).toContainText('Press me');\n});\n```\n\n### findAllWhere<Type = unknown>(predicate: (element: Element<unknown>) => boolean): Element<PropsForComponent<Type>>[]\n\nLike `findWhere`, but returns all matches as an array.\n\n### is(type: Type): boolean\n\nReturns a boolean indicating whether the component type matches the passed type.\nThis function also serves as a type guard, so subsequent calls to values like\n`props` are typed as the prop type of the passed component.\n\n```\nimport {Button} from '@stripe/ui-extension-sdk/ui';\n\n// If we omit element.is here, we would not know whether 'href' was a valid prop\nand Typescript\n// would throw an error.\nif (element.is(Button) && element.prop('href') === 'http://example.com') {\n // ...\n}\n```\n\n### prop<K extends keyof Props>(key: K): Props[K]\n\nReturns the current value of the passed prop name.\n\n### props: Props\n\nAll props of the element.\n\n### text: string\n\nThe text content of the element (that is, the string you would get by calling\n`textContent`).\n\n### trigger<K extends FunctionKeys<Props>>(prop: K, …args: Arguments<Props<K>>): ReturnType<Props<K>>\n\nSimulates a function prop being called on your component. This is usually the\nkey to effective testing. After you mount your component, you simulate a change\nin a subcomponent and assert that the resulting tree is in the expected state.\n\nOptionally, each additional argument passed to `trigger` is passed to the\nfunction. This is useful for testing components in isolation.\n\n```\n// App.tsx\nimport {useState} from 'react';\nimport {ContextView, Button} from '@stripe/ui-extension-sdk/ui';\n\nconst App = () => {\n const [buttonText, setButtonText] = useState<string>('Press me');\n return (\n <ContextView title=\"Hello world\">\n <Button onPress={() => setButtonText('You pressed me!')}>\n {buttonText}\n </Button>\n </ContextView>\n );\n};\n\nexport default App;\n\n// App.test.tsx\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport {Button} from '@stripe/ui-extension-sdk/ui';\nimport App from './App';\n\ndescribe('App', () => {\n it('changes button text when pressed', () => {\n const {wrapper} = render(<App />);\n\n expect(wrapper.find(Button)).toContainText('Press me');\n\n // Press the button\n wrapper.find(Button)!.trigger('onPress', 'You pressed me!');\n\n // Expect that the text changed\n expect(wrapper.find(Button)).toContainText('You pressed me!');\n });\n});\n```\n\n### triggerKeypath<T>(keypath: string, …args: any[]): T\n\nLike `trigger()`, but allows you to provide a keypath referencing nested\nobjects. Be aware that limitations in TypeScript prevent the same kind of\ntype-safety that `trigger` guarantees.\n\n```\nconst App = ({action}: {action: {onAction(): void; label: string}}) => (\n <Button type=\"button\" onPress={action.onAction}>\n {action.label}\n </Button>\n);\n\nconst spy = jest.fn();\nconst app = mount(\n <App action={{label: 'Hi', onAction: spy}} />,\n);\napp.triggerKeypath('action.onAction');\nexpect(spy).toHaveBeenCalled();\n```\n\n## Matchers\n\nThe Extension SDK provides [Jest custom\nmatchers](https://jestjs.io/docs/using-matchers). These are imported\nautomatically when you import `@stripe/ui-extension-sdk/testing`.\n\n### toContainComponent(type: RemoteComponentType, props?: object)\n\nAsserts that at least one component matching `type` is in the descendants of the\npassed node. If the second `props` argument is passed, it further filters the\nmatches by components whose props are equal to the passed object. Jest’s\nasymmetric matchers, like `expect.objectContaining`, are fully supported.\n\n```\n// App.tsx\nimport {Button, ContextView} from '@stripe/ui-extension-sdk/ui';\n\nconst App = () => (\n <ContextView title=\"Hello world\">\n <Button onPress={() => console.log('You pressed me!')}>Press me</Button>\n </ContextView>\n);\n\nexport default App;\n\n// App.test.tsx\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport {Button} from '@stripe/ui-extension-sdk/ui';\nimport App from './App';\n\nit('contains a Button', () => {\n const {wrapper} = render(<App />);\n\n expect(wrapper).toContainComponent(Button, {\n onPress: expect.any(Function),\n });\n});\n```\n\n### toContainComponentTimes(type: RemoteComponentType, times: number, props?: object)\n\nIdentical to `.toContainComponent`, but asserts that there are exactly `times`\nmatches within the passed node.\n\n### toHaveProps(props: object)\n\nChecks whether the node has the specified props.\n\n```\n// App.tsx\nimport {Button, ContextView} from '@stripe/ui-extension-sdk/ui';\n\nconst App = () => (\n <ContextView title=\"Hello world\">\n <Button onPress={() => console.log('You pressed me!')}>Press me</Button>\n </ContextView>\n);\n\nexport default App;\n\n// App.test.tsx\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport {Button} from '@stripe/ui-extension-sdk/ui';\nimport App from './App';\n\nit('contains a Button with an onPress function', () => {\n const {wrapper} = render(<App />);\n\n expect(wrapper.find(Button)).toHaveProps({\n onPress: expect.any(Function),\n });\n});\n```\n\n### toContainText(text: string)\n\nChecks that the rendered output of the component contains the passed string as\ntext content (that is, the text is included in what you would get by calling\n`textContent` on all DOM nodes rendered by the component).\n\n```\n// App.tsx\nimport {Button, ContextView} from '@stripe/ui-extension-sdk/ui';\n\nconst App = () => (\n <ContextView title=\"Hello world\">\n <Button>Press me</Button>\n </ContextView>\n);\n\nexport default App;\n\n// App.test.tsx\nimport {render} from '@stripe/ui-extension-sdk/testing';\nimport {Button} from '@stripe/ui-extension-sdk/ui';\nimport App from './App';\n\nit('contains a Button with an onPress function', () => {\n const {wrapper} = render(<App />);\n\n expect(wrapper.find(Button)).toContainText('Press me');\n});\n```\n\n## Mock context props\n\nApp views are passed [context\nprops](https://docs.stripe.com/stripe-apps/reference/extensions-sdk-api#props)\nin the Stripe Dashboard. You can generate a mock context props object for\ntesting purposes using the `getMockContextProps` function.\n\n```\nimport {getMockContextProps} from '@stripe/ui-extension-sdk/testing';\n\nconst context = getMockContextProps();\nconst {wrapper} = render(<App {...context} />);\n```\n\nBy default, the mock context props are standard test values like `id:\n'usr_1234'` and `email: 'user@example.com'`. You can override these values by\npassing in a partial object. The object you pass in is deep-merged with the\ndefault object, so you only need to pass in the values you want to override.\n\n```\nimport {getMockContextProps} from '@stripe/ui-extension-sdk/testing';\n\nconst context = getMockContextProps({\n environment: {\n objectContext: {\n id: 'inv_1234',\n object: 'invoice',\n },\n },\n});\nconst {wrapper} = render(<App {...context} />);\n```\n\n## See also\n\n- [How UI extensions\nwork](https://docs.stripe.com/stripe-apps/how-ui-extensions-work)\n- [UI extension SDK\nreference](https://docs.stripe.com/stripe-apps/reference/extensions-sdk-api)\n- [UI components](https://docs.stripe.com/stripe-apps/components)\n\n## Links\n\n- [Jest](https://jestjs.io)\n- [Button](https://docs.stripe.com/stripe-apps/components/button)\n- [act() block](https://reactjs.org/docs/test-utils.html#act)\n- [timer mocks](https://jestjs.io/docs/timer-mocks)\n- [http://bad.example.com](http://bad.example.com)\n- [http://example.com](http://example.com)\n- [http://example](http://example)\n- [Jest custom matchers](https://jestjs.io/docs/using-matchers)\n- [context\nprops](https://docs.stripe.com/stripe-apps/reference/extensions-sdk-api#props)\n- [How UI extensions\nwork](https://docs.stripe.com/stripe-apps/how-ui-extensions-work)\n- [UI extension SDK\nreference](https://docs.stripe.com/stripe-apps/reference/extensions-sdk-api)\n- [UI components](https://docs.stripe.com/stripe-apps/components)",
  "metadata": {
    "title": "UI testing | Stripe Documentation",
    "description": "Test your Stripe app UI with a set of utilities and helpers.",
    "sourceURL": "https://docs.stripe.com/stripe-apps/ui-testing"
  }
}