{
  "content": "# Automated testing\n\n## Learn how to use automated testing in your Stripe integration.\n\nAutomated testing is a common part of application development, both for server\nand client-side code. Frontend interfaces, like [Stripe\nCheckout](https://docs.stripe.com/payments/checkout) or the [Payment\nElement](https://docs.stripe.com/payments/payment-element), have security\nmeasures in place that prevent automated testing, and Stripe APIs are rate\nlimited. However, you can simulate the output of our interfaces and API requests\nusing mock data to test your application behavior and its ability to [handle\nerrors](https://docs.stripe.com/error-handling).\n\n## Client side testing\n\nIf you want to test your application’s ability to recover from errors such as\ntransaction declines when using the Payment Element, you can return a simulated\n[error object](https://docs.stripe.com/api/errors) by hard-coding error objects\nin your test code, or creating an API service that returns mock errors in an\nHTTP response. The error object represents what would be returned by the\n[confirmPayment\nfunction](https://docs.stripe.com/js/payment_intents/confirm_payment) when a\ncard is declined. See the following section to learn how you can generate a\nsimulated error object.\n\n### Generating an error object\n\nFirst, use a Stripe UI element such as the [Payment\nElement](https://docs.stripe.com/js/element/payment_element) manually to produce\nan error object by confirming a test mode Payment Intent using one of the [test\ncard numbers](https://docs.stripe.com/testing#declined-payments) for declined\npayments. Log the error during the confirmation process as shown below.\n\n```\nconst { error } = await stripe.confirmPayment({\n elements,\n confirmParams: {\n return_url: 'https://example.com'\n },\n}) ;\nif (error) {\n console.log(error)\n}\n```\n\nThis produces an error object logged to the browser console that resembles the\none shown below. The specifics for properties such as `error_code` depend on the\ncard used and the type of error it generates.\n\n```\n{\n \"charge\": \"{{CHARGE_ID}}\",\n \"code\": \"card_declined\",\n \"decline_code\": \"generic_decline\",\n \"doc_url\": \"https://docs.stripe.com/error-codes#card-declined\",\n \"message\": \"Your card has been declined.\",\n \"payment_intent\": {\"id\": \"{{PAYMENT_INTENT_ID}}\", …},\n \"payment_method\": {\"id\": \"{{PAYMENT_METHOD_ID}}\", …},\n \"request_log_url\": \"https://dashboard.stripe.com/test/logs/req_xxxxxxx\",\n \"type\": \"card_error\"\n}\n```\n\nModify your tests to return this error object instead of calling Stripe.js\nfunctions and the Stripe APIs. You can use different [test\ncards](https://docs.stripe.com/testing#declined-payments) to generate errors\nwith different error codes to make sure your application properly handles each\ntype of error.\n\n## Server side testing\n\nYou can use the same approach when testing server-side API calls. You can\ngenerate Stripe API responses manually for various errors and mock the response\nreturned in backend automated testing.\n\nFor example, to write a test to validate that your application can correctly\nhandle an off-session payment requiring 3DS, you can generate the response by\ncreating a Payment Intent with the Payment Method\n`pm_card_authenticationRequired` and confirm set to `true`.\n\n```\ncurl https://api.stripe.com/v1/payment_intents \\\n -u \"sk_test_BQokikJOvBiI2HlWgH4olfQ2:\" \\\n -d amount=2099 \\\n -d currency=usd \\\n -d payment_method=pm_card_authenticationRequired \\\n -d confirm=true \\\n -d off_session=true\n```\n\nThis generates a Payment Intent with a status of `requires_confirmation`, and\nother properties associated with [3DS\nAuthentication](https://docs.stripe.com/payments/3d-secure) like `next_action`.\n\n```\n{\n \"id\": \"{{PAYMENT_INTENT_ID}}\",\n \"object\": \"payment_intent\",\n ...\n\t\"next_action\": {\n \"type\": \"use_stripe_sdk\",\n ...\n },\n ...\n \"status\": \"requires_confirmation\",\n ...\n}\n```\n\nGenerating PaymentIntent objects that reflect different stages of the [Payment\nlifecycle](https://docs.stripe.com/payments/paymentintents/lifecycle) allows you\nto test your application’s behavior as the PaymentIntent transitions through\nvarious states. Use this approach in your automated testing to make sure your\nintegration can successfully respond to different outcomes, such as requesting\nthat the customer comes back on-session to authenticate a payment that requires\na next action.\n\n#### When to use this approach\n\nThe above examples all reference testing the behavior of your application and\nare suitable to use in a continuous integration test suite. When you need to\nperform tests to validate the response of the Stripe API, making requests to the\nAPI in test mode is an acceptable approach. You can also use Stripe API requests\nto periodically validate that Stripe API responses haven’t changed—but you\nshould perform these tests infrequently to avoid [rate\nlimits](https://docs.stripe.com/rate-limits).\n\n## Links\n\n- [Stripe Checkout](https://docs.stripe.com/payments/checkout)\n- [Payment Element](https://docs.stripe.com/payments/payment-element)\n- [handle errors](https://docs.stripe.com/error-handling)\n- [error object](https://docs.stripe.com/api/errors)\n- [confirmPayment\nfunction](https://docs.stripe.com/js/payment_intents/confirm_payment)\n- [Payment Element](https://docs.stripe.com/js/element/payment_element)\n- [test card numbers](https://docs.stripe.com/testing#declined-payments)\n- [https://example.com](https://example.com)\n- [3DS Authentication](https://docs.stripe.com/payments/3d-secure)\n- [Payment lifecycle](https://docs.stripe.com/payments/paymentintents/lifecycle)\n- [rate limits](https://docs.stripe.com/rate-limits)",
  "metadata": {
    "title": "Automated testing | Stripe Documentation",
    "description": "Learn how to use automated testing in your Stripe integration.",
    "sourceURL": "https://docs.stripe.com/automated-testing"
  }
}