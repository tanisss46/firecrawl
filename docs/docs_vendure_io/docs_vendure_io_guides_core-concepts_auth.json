{
  "content": "[Skip to main content](https://docs.vendure.io/guides/core-concepts/auth/#__docusaurus_skipToContent_fallback)\n\nOn this page\n\n**Authentication** is the process of determining the identity of a user. Common ways of authenticating a user are by asking the user for secret credentials (username & password) or by a third-party authentication provider such as Facebook or Google login.\n\n**Authorization** is a related concept, which means that once we have verified the identity of a user, we can then determine what that user is allowed to do. For example, a user may be authorized to view a product, but not to edit it.\n\nThe term **auth** is shorthand for _both_ authentication and authorization.\n\nAuth in Vendure applies to both **administrators** and **customers**. Authentication is controlled by the configured `AuthenticationStrategies`, and authorization is controlled by the configured `Roles` and `Permissions`.\n\n## Administrator auth [​](https://docs.vendure.io/guides/core-concepts/auth/\\#administrator-auth \"Direct link to Administrator auth\")\n\nAdministrators are required to authenticate before they can perform any operations in the Admin API.\n\nHere is a diagram of the parts that make up Administrator authentication:\n\n![Administrator authentication](https://docs.vendure.io/assets/images/admin-2dc52128cc0f3c264b99bafe540ef0d3.webp)\n\nRoles can be created to allow fine-grained control over what a particular administrator has access to (see the section below).\n\n## Customer auth [​](https://docs.vendure.io/guides/core-concepts/auth/\\#customer-auth \"Direct link to Customer auth\")\n\nCustomer only need to authenticate if they want to access a restricted operation related to their account, such as\nviewing past orders or updating an address.\n\nHere are the parts that make up Customer authentication:\n\n![Customer authentication](https://docs.vendure.io/assets/images/customer-055fccec335d6d0a20a75e10d87a18c7.webp)\n\n### Guest customers [​](https://docs.vendure.io/guides/core-concepts/auth/\\#guest-customers \"Direct link to Guest customers\")\n\nVendure also supports **guest customers**, meaning that a customer can place an order without needing to register an account, and thus not getting an\nassociated user or role. A guest customer, having no roles and thus no permissions, is then unable to view past orders or access any other restricted API\noperations.\n\nHowever, a guest customer can at a later point register an account using the same email address, at which point they will get a user with the \"Customer\" role,\nand be able to view their past orders.\n\n## Roles & Permissions [​](https://docs.vendure.io/guides/core-concepts/auth/\\#roles--permissions \"Direct link to Roles & Permissions\")\n\nBoth the `Customer` and `Administrator` entities relate to a single [`User`](https://docs.vendure.io/reference/typescript-api/entities/user/) entity which in turn has one or more [`Roles`](https://docs.vendure.io/reference/typescript-api/entities/role/) for controlling permissions.\n\n![Administrators &amp; Roles](https://docs.vendure.io/assets/images/admin-role-026714fd03f40a1f08d6d2dc1c249930.webp)\n\nIn the example above, the administrator Sam Bailey has two roles assigned: \"Order Manager\" and \"Catalog Manager\". An administrator\ncan have any number of roles assigned, and the permissions of all roles are combined to determine the permissions of the\nadministrator. In this way, you can have fine-grained control over which administrators can perform which actions.\n\nThere are 2 special roles which are created by default and cannot be changed:\n\n- **SuperAdmin**: This role has all permissions, and cannot be edited or deleted. It is assigned to the first administrator\ncreated when the server is started.\n- **Customer**: This role is assigned to all registered customers.\n\nAll other roles can be user-defined. Here's an example of an \"Inventory Manager\" role being defined in the Admin UI:\n\n![Inventory Manager role](https://docs.vendure.io/assets/images/roles-d81f670eeb611a64befbc7b7285d696c.webp)\n\n## Native authentication [​](https://docs.vendure.io/guides/core-concepts/auth/\\#native-authentication \"Direct link to Native authentication\")\n\nBy default, Vendure uses a username/email address and password to authenticate users, which is implemented by the [`NativeAuthenticationStrategy`](https://docs.vendure.io/reference/typescript-api/auth/native-authentication-strategy/).\n\nThere is a `login` mutation available in both the Shop API and Admin API which allows a customer or administrator to authenticate using\nnative authentication:\n\nAdmin API\n\n```codeBlockLines_e6Vv\nmutation {\n  login(username: \"superadmin\", password: \"superadmin\") {\n    ...on CurrentUser {\n      id\n      identifier\n    }\n    ...on ErrorResult {\n      errorCode\n      message\n    }\n  }\n}\n\n```\n\ninfo\n\nSee the [Managing Sessions guide](https://docs.vendure.io/guides/storefront/connect-api/#managing-sessions) for how to manage authenticated sessions in your storefront/client applications.\n\n## External authentication [​](https://docs.vendure.io/guides/core-concepts/auth/\\#external-authentication \"Direct link to External authentication\")\n\nIn addition to the built-in `NativeAuthenticationStrategy`, it is possible to define a custom [`AuthenticationStrategy`](https://docs.vendure.io/reference/typescript-api/auth/authentication-strategy) which allows your Vendure server to support other authentication methods such as:\n\n- Social logins (Facebook, Google, GitHub, etc.)\n- Single Sign-On (SSO) providers such as Keycloak, Auth0, etc.\n- Alternative factors such as SMS, TOTP, etc.\n\nCustom authentication strategies are set via the [`VendureConfig.authOptions` object](https://docs.vendure.io/reference/typescript-api/auth/auth-options/#shopauthenticationstrategy):\n\nsrc/vendure-config.ts\n\n```codeBlockLines_e6Vv\nimport { VendureConfig, NativeAuthenticationStrategy } from '@vendure/core';\n\nimport { FacebookAuthenticationStrategy } from './plugins/authentication/facebook-authentication-strategy';\nimport { GoogleAuthenticationStrategy } from './plugins/authentication/google-authentication-strategy';\nimport { KeycloakAuthenticationStrategy } from './plugins/authentication/keycloak-authentication-strategy';\n\nexport const config: VendureConfig = {\n  authOptions: {\n      shopAuthenticationStrategy: [\\\n        new NativeAuthenticationStrategy(),\\\n        new FacebookAuthenticationStrategy(),\\\n        new GoogleAuthenticationStrategy(),\\\n      ],\n      adminAuthenticationStrategy: [\\\n        new NativeAuthenticationStrategy(),\\\n        new KeycloakAuthenticationStrategy(),\\\n      ],\n  }\n}\n\n```\n\nIn the above example, we define the strategies available for authenticating in the Shop API and the Admin API. The `NativeAuthenticationStrategy` is the only one actually provided by Vendure out-of-the-box, and this is the default username/email + password strategy.\n\nThe other strategies would be custom-built (or provided by future npm packages) by creating classes that implement the [`AuthenticationStrategy` interface](https://docs.vendure.io/reference/typescript-api/auth/authentication-strategy).\n\nLet's take a look at a couple of examples of what a custom AuthenticationStrategy implementation would look like.\n\n## Custom authentication examples [​](https://docs.vendure.io/guides/core-concepts/auth/\\#custom-authentication-examples \"Direct link to Custom authentication examples\")\n\n### Google authentication [​](https://docs.vendure.io/guides/core-concepts/auth/\\#google-authentication \"Direct link to Google authentication\")\n\nThis example demonstrates how to implement a Google login flow.\n\n#### Storefront setup [​](https://docs.vendure.io/guides/core-concepts/auth/\\#storefront-setup \"Direct link to Storefront setup\")\n\nIn your storefront, you need to integrate the Google sign-in button as described in [\"Integrating Google Sign-In into your web app\"](https://developers.google.com/identity/sign-in/web/sign-in). Successful authentication will result in a `onSignIn` function being called in your app. It will look something like this:\n\n```codeBlockLines_e6Vv\nfunction onSignIn(googleUser) {\n  graphQlQuery(\n    `mutation Authenticate($token: String!) {\n        authenticate(input: {\n          google: { token: $token }\n        }) {\n        ...on CurrentUser {\n            id\n            identifier\n        }\n      }\n    }`,\n    { token: googleUser.getAuthResponse().id_token }\n  ).then(() => {\n    // redirect to account page\n  });\n}\n\n```\n\n#### Backend [​](https://docs.vendure.io/guides/core-concepts/auth/\\#backend \"Direct link to Backend\")\n\nOn the backend, you'll need to define an AuthenticationStrategy to take the authorization token provided by the\nstorefront in the `authenticate` mutation, and use it to get the necessary personal information on that user from\nGoogle.\n\nTo do this you'll need to install the `google-auth-library` npm package as described in the [\"Authenticate with a backend server\" guide](https://developers.google.com/identity/sign-in/web/backend-auth).\n\nsrc/plugins/authentication/google-authentication-strategy.ts\n\n```codeBlockLines_e6Vv\nimport {\n    AuthenticationStrategy,\n    ExternalAuthenticationService,\n    Injector,\n    RequestContext,\n    User,\n} from '@vendure/core';\nimport { OAuth2Client } from 'google-auth-library';\nimport { DocumentNode } from 'graphql';\nimport gql from 'graphql-tag';\n\nexport type GoogleAuthData = {\n    token: string;\n};\n\nexport class GoogleAuthenticationStrategy implements AuthenticationStrategy<GoogleAuthData> {\n    readonly name = 'google';\n    private client: OAuth2Client;\n    private externalAuthenticationService: ExternalAuthenticationService;\n\n    constructor(private clientId: string) {\n        // The clientId is obtained by creating a new OAuth client ID as described\n        // in the Google guide linked above.\n        this.client = new OAuth2Client(clientId);\n    }\n\n    init(injector: Injector) {\n        // The ExternalAuthenticationService is a helper service which encapsulates much\n        // of the common functionality related to dealing with external authentication\n        // providers.\n        this.externalAuthenticationService = injector.get(ExternalAuthenticationService);\n    }\n\n    defineInputType(): DocumentNode {\n        // Here we define the expected input object expected by the `authenticate` mutation\n        // under the \"google\" key.\n        return gql`\n        input GoogleAuthInput {\n            token: String!\n        }\n    `;\n    }\n\n    async authenticate(ctx: RequestContext, data: GoogleAuthData): Promise<User | false> {\n        // Here is the logic that uses the token provided by the storefront and uses it\n        // to find the user data from Google.\n        const ticket = await this.client.verifyIdToken({\n            idToken: data.token,\n            audience: this.clientId,\n        });\n        const payload = ticket.getPayload();\n        if (!payload || !payload.email) {\n            return false;\n        }\n\n        // First we check to see if this user has already authenticated in our\n        // Vendure server using this Google account. If so, we return that\n        // User object, and they will be now authenticated in Vendure.\n        const user = await this.externalAuthenticationService.findCustomerUser(ctx, this.name, payload.sub);\n        if (user) {\n            return user;\n        }\n\n        // If no user was found, we need to create a new User and Customer based\n        // on the details provided by Google. The ExternalAuthenticationService\n        // provides a convenience method which encapsulates all of this into\n        // a single method call.\n        return this.externalAuthenticationService.createCustomerAndUser(ctx, {\n            strategy: this.name,\n            externalIdentifier: payload.sub,\n            verified: payload.email_verified || false,\n            emailAddress: payload.email,\n            firstName: payload.given_name,\n            lastName: payload.family_name,\n        });\n    }\n}\n\n```\n\n### Facebook authentication [​](https://docs.vendure.io/guides/core-concepts/auth/\\#facebook-authentication \"Direct link to Facebook authentication\")\n\nThis example demonstrates how to implement a Facebook login flow.\n\n#### Storefront setup [​](https://docs.vendure.io/guides/core-concepts/auth/\\#storefront-setup-1 \"Direct link to Storefront setup\")\n\nIn this example, we are assuming the use of the [Facebook SDK for JavaScript](https://developers.facebook.com/docs/javascript/) in the storefront.\n\nAn implementation in React might look like this:\n\n/storefront/src/components/FacebookLoginButton.tsx\n\n```codeBlockLines_e6Vv\n/**\n * Renders a Facebook login button.\n */\nexport const FBLoginButton = () => {\n    const fnName = `onFbLoginButtonSuccess`;\n    const router = useRouter();\n    const [error, setError] = useState('');\n    const [socialLoginMutation] = useMutation(AuthenticateDocument);\n\n    useEffect(() => {\n        (window as any)[fnName] = function() {\n            FB.getLoginStatus(login);\n        };\n        return () => {\n            delete (window as any)[fnName];\n        };\n    }, []);\n\n    useEffect(() => {\n        window?.FB?.XFBML.parse();\n    }, []);\n\n    const login = async (response: any) => {\n        const {status, authResponse} = response;\n        if (status === 'connected') {\n            const result = await socialLoginMutation({variables: {token: authResponse.accessToken}});\n            if (result.data?.authenticate.__typename === 'CurrentUser') {\n                // The user has logged in, refresh the browser\n                trackLogin('facebook');\n                router.reload();\n                return;\n            }\n        }\n        setError('An error occurred!');\n    };\n\n    return (\n        <div className=\"text-center\" style={{ width: 188, height: 28 }}>\n            <FacebookSDK />\n            <div\n                className=\"fb-login-button\"\n                data-width=\"\"\n                data-size=\"medium\"\n                data-button-type=\"login_with\"\n                data-layout=\"default\"\n                data-auto-logout-link=\"false\"\n                data-use-continue-as=\"false\"\n                data-scope=\"public_profile,email\"\n                data-onlogin={`${fnName}();`}\n            />\n            {error && <div className=\"text-sm text-red-500\">{error}</div>}\n        </div>\n  );\n};\n\n```\n\n#### Backend [​](https://docs.vendure.io/guides/core-concepts/auth/\\#backend-1 \"Direct link to Backend\")\n\n/src/plugins/authentication/facebook-authentication-strategy.ts\n\n```codeBlockLines_e6Vv\nimport {\n    AuthenticationStrategy,\n    ExternalAuthenticationService,\n    Injector,\n    Logger,\n    RequestContext,\n    User,\n    UserService,\n} from '@vendure/core';\n\nimport { DocumentNode } from 'graphql';\nimport gql from 'graphql-tag';\nimport fetch from 'node-fetch';\n\nexport type FacebookAuthData = {\n    token: string;\n};\n\nexport type FacebookAuthConfig = {\n    appId: string;\n    appSecret: string;\n    clientToken: string;\n};\n\nexport class FacebookAuthenticationStrategy implements AuthenticationStrategy<FacebookAuthData> {\n    readonly name = 'facebook';\n    private externalAuthenticationService: ExternalAuthenticationService;\n    private userService: UserService;\n\n    constructor(private config: FacebookAuthConfig) {\n    }\n\n    init(injector: Injector) {\n        // The ExternalAuthenticationService is a helper service which encapsulates much\n        // of the common functionality related to dealing with external authentication\n        // providers.\n        this.externalAuthenticationService = injector.get(ExternalAuthenticationService);\n        this.userService = injector.get(UserService);\n    }\n\n    defineInputType(): DocumentNode {\n        // Here we define the expected input object expected by the `authenticate` mutation\n        // under the \"google\" key.\n        return gql`\n      input FacebookAuthInput {\n        token: String!\n      }\n    `;\n    }\n\n    private async getAppAccessToken() {\n        const resp = await fetch(\n            `https://graph.facebook.com/oauth/access_token?client_id=${this.config.appId}&client_secret=${this.config.appSecret}&grant_type=client_credentials`,\n        );\n        return await resp.json();\n    }\n\n    async authenticate(ctx: RequestContext, data: FacebookAuthData): Promise<User | false> {\n        const {token} = data;\n        const {access_token} = await this.getAppAccessToken();\n        const resp = await fetch(\n            `https://graph.facebook.com/debug_token?input_token=${token}&access_token=${access_token}`,\n        );\n        const result = await resp.json();\n\n        if (!result.data) {\n            return false;\n        }\n\n        const uresp = await fetch(`https://graph.facebook.com/me?access_token=${token}&fields=email,first_name,last_name`);\n        const uresult = (await uresp.json()) as { id?: string; email: string; first_name: string; last_name: string };\n\n        if (!uresult.id) {\n            return false;\n        }\n\n        const existingUser = await this.externalAuthenticationService.findCustomerUser(ctx, this.name, uresult.id);\n\n        if (existingUser) {\n            // This will select all the auth methods\n            return (await this.userService.getUserById(ctx, existingUser.id))!;\n        }\n\n        Logger.info(`User Create: ${JSON.stringify(uresult)}`);\n        const user = await this.externalAuthenticationService.createCustomerAndUser(ctx, {\n            strategy: this.name,\n            externalIdentifier: uresult.id,\n            verified: true,\n            emailAddress: uresult.email,\n            firstName: uresult.first_name,\n            lastName: uresult.last_name,\n        });\n\n        user.verified = true;\n        return user;\n    }\n}\n\n```\n\n### Keycloak authentication [​](https://docs.vendure.io/guides/core-concepts/auth/\\#keycloak-authentication \"Direct link to Keycloak authentication\")\n\nHere's an example of an AuthenticationStrategy intended to be used on the Admin API. The use-case is when the company has an existing identity server for employees, and you'd like your Vendure shop admins to be able to authenticate with their existing accounts.\n\nThis example uses [Keycloak](https://www.keycloak.org/), a popular open-source identity management server. To get your own Keycloak server up and running in minutes, follow the [Keycloak on Docker](https://www.keycloak.org/getting-started/getting-started-docker) guide.\n\n#### Configure a login page & Admin UI [​](https://docs.vendure.io/guides/core-concepts/auth/\\#configure-a-login-page--admin-ui \"Direct link to Configure a login page & Admin UI\")\n\nIn this example, we'll assume the login page is hosted at `http://intranet/login`. We'll also assume that a \"login to Vendure\" button has been added to that page and that the page is using the [Keycloak JavaScript adapter](https://www.keycloak.org/docs/latest/securing_apps/index.html#_javascript_adapter), which can be used to get the current user's authorization token:\n\n/login/index.html\n\n```codeBlockLines_e6Vv\nconst vendureLoginButton = document.querySelector('#vendure-login-button');\n\nvendureLoginButton.addEventListener('click', () => {\n  return graphQlQuery(`\n    mutation Authenticate($token: String!) {\n      authenticate(input: {\n        keycloak: {\n          token: $token\n        }\n      }) {\n        ...on CurrentUser { id }\n      }\n    }`,\n    { token: keycloak.token },\n  )\n  .then((result) => {\n      if (result.data?.authenticate.user) {\n          // successfully authenticated - redirect to Vendure Admin UI\n          window.location.replace('http://localhost:3000/admin');\n      }\n  });\n});\n\n```\n\nWe also need to tell the Admin UI application about the custom login URL, since we have no need for the default \"username/password\" login form. This can be done by setting the [`loginUrl` property](https://docs.vendure.io/reference/typescript-api/common/admin-ui/admin-ui-config#loginurl) in the AdminUiConfig:\n\n/src/vendure-config.ts\n\n```codeBlockLines_e6Vv\nimport { VendureConfig } from '@vendure/core';\nimport { AdminUiPlugin } from '@vendure/admin-ui-plugin';\n\nexport const config: VendureConfig = {\n    // ...\n    plugins: [\\\n        AdminUiPlugin.init({\\\n            port: 5001,\\\n            adminUiConfig: {\\\n                loginUrl: 'http://intranet/login',\\\n            },\\\n        }),\\\n    ],\n};\n\n```\n\n#### Backend [​](https://docs.vendure.io/guides/core-concepts/auth/\\#backend-2 \"Direct link to Backend\")\n\nFirst we will need to be making an HTTP call to our Keycloak server to validate the token and get the user's details. We'll use the [`node-fetch`](https://www.npmjs.com/package/node-fetch) library to make the HTTP call:\n\n```codeBlockLines_e6Vv\nnpm install node-fetch\n\n```\n\nThe strategy is very similar to the Google authentication example (they both use the OpenID Connect standard), so we'll not duplicate the explanatory comments here:\n\n/src/plugins/authentication/keycloak-authentication-strategy.ts\n\n```codeBlockLines_e6Vv\nimport fetch from 'node-fetch';\nimport {\n    AuthenticationStrategy,\n    ExternalAuthenticationService,\n    Injector,\n    Logger,\n    RequestContext,\n    RoleService,\n    User,\n} from '@vendure/core';\nimport { DocumentNode } from 'graphql';\nimport gql from 'graphql-tag';\n\nexport type KeycloakAuthData = {\n    token: string;\n};\n\nexport class KeycloakAuthenticationStrategy implements AuthenticationStrategy<KeycloakAuthData> {\n    readonly name = 'keycloak';\n    private externalAuthenticationService: ExternalAuthenticationService;\n    private httpService: HttpService;\n    private roleService: RoleService;\n\n    init(injector: Injector) {\n        this.externalAuthenticationService = injector.get(ExternalAuthenticationService);\n        this.httpService = injector.get(HttpService);\n        this.roleService = injector.get(RoleService);\n    }\n\n    defineInputType(): DocumentNode {\n        return gql`\n      input KeycloakAuthInput {\n        token: String!\n      }\n    `;\n    }\n\n    async authenticate(ctx: RequestContext, data: KeycloakAuthData): Promise<User | false> {\n        const { data: userInfo } = await fetch(\n            'http://localhost:9000/auth/realms/myrealm/protocol/openid-connect/userinfo', {\n                headers: {\n                    Authorization: `Bearer ${data.token}`,\n                },\n            }).then(res => res.json());\n\n        if (!userInfo) {\n            return false;\n        }\n        const user = await this.externalAuthenticationService.findAdministratorUser(ctx, this.name, userInfo.sub);\n        if (user) {\n            return user;\n        }\n\n        // When creating an Administrator, we need to know what Role(s) to assign.\n        // In this example, we've created a \"merchant\" role and assign that to all\n        // new Administrators. In a real implementation, you can have more complex\n        // logic to map an external user to a given role.\n        const roles = await this.roleService.findAll();\n        const merchantRole = roles.items.find((r) => r.code === 'merchant');\n        if (!merchantRole) {\n            Logger.error(`Could not find \"merchant\" role`);\n            return false;\n        }\n\n        return this.externalAuthenticationService.createAdministratorAndUser(ctx, {\n            strategy: this.name,\n            externalIdentifier: userInfo.sub,\n            identifier: userInfo.preferred_username,\n            emailAddress: userInfo.email,\n            firstName: userInfo.given_name,\n            lastName: userInfo.family_name,\n            roles: [merchantRole],\n        });\n    }\n}\n\n```\n\n- [Administrator auth](https://docs.vendure.io/guides/core-concepts/auth/#administrator-auth)\n- [Customer auth](https://docs.vendure.io/guides/core-concepts/auth/#customer-auth)\n  - [Guest customers](https://docs.vendure.io/guides/core-concepts/auth/#guest-customers)\n- [Roles & Permissions](https://docs.vendure.io/guides/core-concepts/auth/#roles--permissions)\n- [Native authentication](https://docs.vendure.io/guides/core-concepts/auth/#native-authentication)\n- [External authentication](https://docs.vendure.io/guides/core-concepts/auth/#external-authentication)\n- [Custom authentication examples](https://docs.vendure.io/guides/core-concepts/auth/#custom-authentication-examples)\n  - [Google authentication](https://docs.vendure.io/guides/core-concepts/auth/#google-authentication)\n  - [Facebook authentication](https://docs.vendure.io/guides/core-concepts/auth/#facebook-authentication)\n  - [Keycloak authentication](https://docs.vendure.io/guides/core-concepts/auth/#keycloak-authentication)",
  "metadata": {
    "url": "https://docs.vendure.io/guides/core-concepts/auth/",
    "ogUrl": "https://docs.vendure.io/guides/core-concepts/auth/",
    "title": "Auth | Vendure Docs",
    "og:url": "https://docs.vendure.io/guides/core-concepts/auth/",
    "favicon": {},
    "ogImage": "https://docs.vendure.io/img/docusaurus-social-card.jpg",
    "ogTitle": "Auth | Vendure Docs",
    "language": "en",
    "og:image": "https://docs.vendure.io/img/docusaurus-social-card.jpg",
    "og:title": "Auth | Vendure Docs",
    "ogLocale": "en",
    "scrapeId": "2c6edcbe-5431-42e3-a180-3814c1f6898c",
    "viewport": "width=device-width, initial-scale=1.0",
    "generator": "Docusaurus v3.4.0",
    "og:locale": "en",
    "sourceURL": "https://docs.vendure.io/guides/core-concepts/auth/",
    "statusCode": 200,
    "description": "Authentication is the process of determining the identity of a user. Common ways of authenticating a user are by asking the user for secret credentials (username & password) or by a third-party authentication provider such as Facebook or Google login.",
    "twitter:card": "summary_large_image",
    "ogDescription": "Authentication is the process of determining the identity of a user. Common ways of authenticating a user are by asking the user for secret credentials (username & password) or by a third-party authentication provider such as Facebook or Google login.",
    "twitter:image": "https://docs.vendure.io/img/docusaurus-social-card.jpg",
    "docusaurus_tag": "docs-default-current",
    "og:description": "Authentication is the process of determining the identity of a user. Common ways of authenticating a user are by asking the user for secret credentials (username & password) or by a third-party authentication provider such as Facebook or Google login.",
    "docsearch:version": "current",
    "docusaurus_locale": "en",
    "docsearch:language": "en",
    "docusaurus_version": "current",
    "docsearch:docusaurus_tag": "docs-default-current"
  }
}